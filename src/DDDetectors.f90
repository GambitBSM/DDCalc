MODULE DDDetectors

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
! DDDetectors
!    Routines for initializing and modifying the detector setup,
!    notatably by setting isotopes to use, loading efficiencies from
!    file, and tabulating form factors.
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

USE DDTypes
USE DDCommandLine
USE DDNuclear
USE DDUtils
USE DDInput
USE DDOutput

IMPLICIT NONE

PUBLIC :: DDCalc_GetDetector,DDCalc_SetDetector
INTERFACE DDCalc_GetDetector
  MODULE PROCEDURE GetDetector
END INTERFACE
INTERFACE DDCalc_SetDetector
  MODULE PROCEDURE SetDetector
END INTERFACE

CONTAINS


!=======================================================================
! DETECTOR EFFICIENCY/RESPONSE ROUTINES
!=======================================================================

! ----------------------------------------------------------------------
! Sets the efficiencies to those found in the given file, presumably
! an efficiency or efficiencies file generated by TPCMC.
! 
! Required input argument:
!     file       The file to load efficiencies from.
!     Niso       Number of isotopes of the experiment under consideration
!     Nbins      Number of intervals/bins expected.
! Required output arguments:
!     NE         Number of recoil energy tabulation points loaded
!     E          Allocatable array to contain energies [keV].
!                Allocated to size [1:NE].
!     eff        Allocatable array to contain efficiency curves for
!                the total range and each interval/bin.  Allocated to
!                size [1:NE,0:Nbins].
! 
! IMPORTANT:
! Currently, this function assigns the same efficiency to all isotopes.
! In case one wants to use isotope-dependent efficiencies loaded from files,
! the function has to be expanded.
!
SUBROUTINE LoadEfficiencyFile(file,Niso,Nbins,NE,E,eff)
  IMPLICIT NONE
  CHARACTER(LEN=*), INTENT(IN) :: file
  INTEGER, INTENT(IN) :: Niso,Nbins
  INTEGER, INTENT(OUT) :: NE
  REAL*8, ALLOCATABLE, INTENT(OUT) :: E(:),eff(:,:,:)
  LOGICAL :: status
  INTEGER :: Kcol,Keff,Nrow,Ncol,Nvalid,Kiso,Neff
  REAL*8, ALLOCATABLE :: data(:,:)
  
  ! Load table from file
  CALL LoadTable(file=file,Nrow=Nrow,Ncol=Ncol,data=data,status=status)
  IF ((.NOT. status) .OR. (Ncol .LT. 2)) THEN
    WRITE(0,*) 'ERROR: Failed to load data from file ' // TRIM(file) // '.'
    STOP
  END IF
  
  ! Energies
  NE = Nrow
  ALLOCATE(E(NE))
  E = data(:,1)
  
  ! Find number of valid efficiency columns
  Nvalid = 0
  DO Kcol = 2,Ncol
    IF (ALL(data(:,Kcol) .GE. 0d0) .AND. ALL(data(:,Kcol) .LE. 1.00001d0)) Nvalid = Nvalid + 1
  END DO
  IF (Nvalid .LE. 0) THEN
    WRITE(0,*) 'ERROR: Failed to find valid data in file ' // TRIM(file) // '.'
    STOP
  END IF
  
  ! Now get efficiencies
  Neff = Nvalid - 1
  IF ( Neff .EQ. Nbins ) THEN
    ALLOCATE(eff(Niso,NE,0:Neff))
    Keff = 0
    DO Kcol = 2,Ncol
      IF (ALL(data(:,Kcol) .GE. 0d0) .AND. ALL(data(:,Kcol) .LE. 1.00001d0) &
          .AND. (Keff .LE. Neff)) THEN
        DO Kiso = 1,Niso
          eff(Kiso,:,Keff) = data(:,Kcol)
        END DO
        Keff = Keff + 1
      END IF
    END DO
  ELSE
    WRITE(0,*) 'ERROR: Number of entries in file ' // TRIM(file) // ' does not agree with expectation.'
    STOP
  END IF

  
END SUBROUTINE



!=======================================================================
! DETECTOR SETUP ROUTINES
!=======================================================================

! ----------------------------------------------------------------------
! Get various detector quantities.
! Note this only allows access to fixed quantities, not quantities that
! are recalculated for each WIMP (see GetRates() for that).
! 
! Optional input argument:
!   D           The DetectorStruct structure to extract detector
!               quantities from.  If not given, a default structure
!               (internally stored) will be used.
! Optional output arguments:
!   mass        Detector fiducial mass [kg]
!   time        Detector exposure time [day]
!   exposure    Detector exposure [kg day]
!   Nevents     Allocatable integer array containing the number of observed 
!               events. Allocated to size [0:Nbins]
!   Backgr      Allocatable integer array containing the average expected 
!               background events. Allocated to size [0:Nbins]
!   Niso        Number of isotopes
!   Ziso        Allocatable integer array to be filled with isotope
!               atomic numbers. Allocated to size [1:Niso].
!   Aiso        Allocatable integer array to be filled with isotope
!               atomic mass numbers. Allocated to size [1:Niso].
!   fiso        Allocatable real array to be filled with isotope
!               mass fractions. Allocated to size [1:Niso].
!   Miso        Allocatable real array to be filled with isotope
!               nuclear masses [GeV]. Allocated to size [1:Niso].
!   NE          Number of tabulated recoil energies E
!   E           Allocatable real array to be filled with recoil energies
!               [keV]. Allocated to size [1:NE].
!   eff_file    File from which efficiencies were read
!   Nbins       Number of subintervals (0 for only total interval)
!   eff         Allocatable dimension=3 array containing efficiencies
!               as a function of recoil energy. Allocated to size
!               [1:Niso,1:NE,0:Nbins], where the first index is over isotopes
!               the second index is over recoil energies and the third
!               index is over the sub-interval number (0 for the total interval).
!   Wsi,Wsd     Allocatable dimension=3 array containing weighted form
!               factors for spin-independent (SI) and spin-dependent
!               (SD) couplings.  Allocated to size [-1:1,1:NE,1:Niso].
!   intervals   LOGICAL indicating if rates for intervals/bins are
!               to be calculated (used for max gap).
! 
SUBROUTINE GetDetector(D,mass,time,exposure,Nevents,background,         &
                       Niso,Ziso,Aiso,fiso,Miso,NE,E,                   &
                       eff_file,Nbins,eff,                              &
                       Wsi,Wsd,intervals)
  IMPLICIT NONE
  TYPE(DetectorStruct), INTENT(IN) :: D
  LOGICAL, INTENT(OUT), OPTIONAL :: intervals
  CHARACTER(LEN=*), INTENT(OUT), OPTIONAL :: eff_file
  INTEGER, INTENT(OUT), OPTIONAL :: Nevents(:),Niso,NE,Nbins
  INTEGER, ALLOCATABLE, INTENT(OUT), OPTIONAL :: Ziso(:),Aiso(:)
  REAL*8, INTENT(OUT), OPTIONAL :: mass,time,exposure,background(:)
  REAL*8, ALLOCATABLE, INTENT(OUT), OPTIONAL :: fiso(:),Miso(:),E(:),   &
          eff(:,:,:),Wsi(:,:,:),Wsd(:,:,:)
  
  IF ( .NOT. D%InitSuccess ) THEN
    WRITE(*,*) 'ERROR: Cannot get information from a detector that has not been correctly initialized.'
    STOP      
  END IF

  ! Exposures
  IF (PRESENT(mass))     mass     = D%mass
  IF (PRESENT(time))     time     = D%time
  IF (PRESENT(exposure)) exposure = D%exposure
  
  ! Observed events and expected background events
  IF (PRESENT(Nevents))    Nevents    = D%Nevents
  IF (PRESENT(background)) background = D%Backgr
  
  ! Isotope data
  IF (PRESENT(Niso)) Niso = D%Niso
  IF (PRESENT(Ziso)) THEN
    ALLOCATE(Ziso(D%Niso))
    Ziso = D%Ziso
  END IF
  IF (PRESENT(Aiso)) THEN
    ALLOCATE(Aiso(D%Niso))
    Aiso = D%Aiso
  END IF
  IF (PRESENT(fiso)) THEN
    ALLOCATE(fiso(D%Niso))
    fiso = D%fiso
  END IF
  IF (PRESENT(Miso)) THEN
    ALLOCATE(Miso(D%Niso))
    Miso = D%Miso
  END IF
  
  ! Recoil energies
  IF (PRESENT(NE)) NE = D%NE
  IF (PRESENT(E)) THEN
    ALLOCATE(E(D%NE))
    E = D%E
  END IF
  
  ! Efficiencies
  IF (PRESENT(eff_file)) eff_file = D%eff_file
  IF (PRESENT(Nbins))     Nbins     = D%Nbins
  IF (PRESENT(eff)) THEN
    ALLOCATE(eff(D%Niso,D%NE,0:D%Nbins))
    eff = D%eff
  END IF
  
  ! Weighted form factors
  IF (PRESENT(Wsi)) THEN
    ALLOCATE(Wsi(-1:1,D%NE,0:D%Niso))
    Wsi = D%Wsi
  END IF
  IF (PRESENT(Wsd)) THEN
    ALLOCATE(Wsd(-1:1,D%NE,0:D%Niso))
    Wsd = D%Wsd
  END IF
  
  ! Calculate rates for intervals/bins?
  IF (PRESENT(intervals)) intervals = D%intervals
  
END SUBROUTINE


! ----------------------------------------------------------------------
! Set various detector quantities.  Making changes will reset all
! per-WIMP calculations like rates.
! Note this only allows access to fixed quantities, or quantities that
! need be calculated only once, not quantities that are recalculated
! for each WIMP (see SetRates() for that).
! 
! Optional input/output argument:
!   D           The DetectorStruct structure containing detector
!               data to be modified.  If not given, a default structure
!               (internally stored) will be used.
! Optional input arguments:
!   mass        Detector fiducial mass [kg]
!   time        Detector exposure time [day]
!   exposure    Detector exposure [kg day]
!   Nbins       Number of sub-intervals/bins in data (0 if total only).
!   Nevents_tot Total number of observed events
!   Nevents_bin Array of size [1:Nbins] containing the number of
!               observed events for each interval.
!   Backgr_tot  Total number of expected background events
!   Backgr_bin  Array of size [1:Nbins] containing the average expected 
!               background for each interval.
! Optional isotope-related input arguments.  Niso must be given for
! any of the arrays to be used, regardless if the number has changed.
! If Niso changes, then all of the A/Z/f arrays must be specified for
! changes to take effect (otherwise these inputs are ignored).
!   Niso        Number of isotopes
!   Ziso        Integer array of size [1:Niso] containing atomic
!               numbers.
!   Aiso        Integer array of size [1:Niso] containing atomic
!               mass numbers.
!   fiso        Array of size [1:Niso] containing isotope mass
!               fractions.
! Pre-populated isotopic abundances for compounds with given
! stoichiometry.  The first two of these must be given to take effect
! (otherwise these inputs are ignored).
!   Nelem       Number of elements in compound.
!   Zelem       Integer array of size [1:Nelem] containing atomic
!               numbers of compound elements.
!   stoich      Integer array of size [1:Nelem] containing compound
!               stoichiometry.  For example, CF3Cl would be {1,3,1}.
!               Default is 1 for each element.
! Optional recoil energy tabulation arguments.  Both are required for
! changes to take effect.
!   NE          Number of tabulated recoil energies E
!   E           Array of size [1:NE] containing recoil energies [keV].
!               This defines the energies used for calculating dR/dE
!               and its integral.
! Optional efficiency curve(s) arguments.  Efficiencies can be provided
! by file or by providing tabulation data.
!   eff_file    File from which efficiencies shoud be read.
!   eff_filename Sets the stored file name _without_ loading any data
!               from the file.
!   eff_all     Array of size [1:NE,0:Nbins] containing efficiencies
!               as a function of recoil energy, where the first index
!               is over recoil energies and the second index is over
!               the sub-interval number (0 for the total interval).
!               The same efficiency will be used for all target elements
!               and isotopes.
!   eff         Array of size [1:Niso,1:NE,0:Nbins] containing efficiencies
!               as a function of recoil energy as above, but specified
!               separately for every target isotope.
!               If eff is provided together with Nelem and Zelem, it is
!               taken to have the size [1:Nelem,1:NE,0:Nbins] and the same
!               efficiency will be used for all isotopes of each element
! Optional analysis-related arguments.
!   intervals   Specify if rates for sub-intervals should be calculated;
!               otherwise, only the full interval is used for
!               calculations (default: false).
!               For this to have effect, Nbins must be greater than zero.
!               If intervals is set to true but Nevents_bin is not specified
!               this is taken to mean that the max gap method should be used
!   Emin        If given, sets all efficiencies below the given energy
!               [keV] to zero, removing all contributions from recoils
!               at lower energies.
!

SUBROUTINE SetDetector(D,mass,time,exposure,Nbins,                      &
                       Nevents_tot,Nevents_bin,Backgr_tot,Backgr_bin,   &
                       Niso,Ziso,Aiso,fiso,Nelem,Zelem,stoich,          &
                       NE,E,eff_file,eff_filename,eff,eff_all,          &
                       intervals,Emin)
  IMPLICIT NONE
  TYPE(DetectorStruct), INTENT(INOUT) :: D
  CHARACTER(LEN=*), INTENT(IN), OPTIONAL :: eff_file,eff_filename
  LOGICAL, INTENT(IN), OPTIONAL :: intervals
  INTEGER, INTENT(IN), OPTIONAL :: Nevents_tot,Nevents_bin(:),Niso,Nelem,NE,Nbins
  INTEGER, INTENT(IN), OPTIONAL :: Ziso(:),Aiso(:),Zelem(:),stoich(:)
  REAL*8, INTENT(IN), OPTIONAL :: mass,time,exposure,Backgr_tot,Backgr_bin(:),Emin
  REAL*8, INTENT(IN), OPTIONAL :: fiso(:),E(:),eff(:,:,0:),eff_all(:,0:)
  LOGICAL :: iso_change,E_change,eff_change
  INTEGER :: KE,Kiso,Neff,ind_elem,ind_iso,ind,Niso_temp
  INTEGER, ALLOCATABLE :: stoich0(:)

  ! Indicate if quantities changed, indicating need for
  ! array resizing and initialization
  iso_change = .FALSE.
  E_change   = .FALSE.
  eff_change = .FALSE.

  ! Energy binning
  IF ( (PRESENT(E)) .AND. (PRESENT(NE)) ) THEN
    IF (NE > 0) THEN
      IF (ALLOCATED(D%E) .AND. (NE .NE. D%NE)) DEALLOCATE(D%E)
      IF (.NOT. ALLOCATED(D%E)) ALLOCATE(D%E(NE))
      D%NE = NE
      D%E = E(1:NE)
      IF (ALLOCATED(D%E_cache)) DEALLOCATE(D%E_cache)
      ALLOCATE(D%E_cache(D%NE))
      D%E_cache = D%E
      D%InitSuccess = .False. ! If NE is changed, a new efficiency array must be provided
      E_change = .TRUE.
    END IF
  END IF

  IF (.NOT. D%NE > 0) THEN
    D%InitSuccess = .False.
    RETURN      
  END IF

  ! Observed events and expected background events

  IF ( PRESENT(Nbins) ) THEN
    IF (Nbins .EQ. D%Nbins) THEN
      IF ( PRESENT(Nevents_tot) ) THEN
        D%Nevents(0) = Nevents_tot
      END IF
      IF ( PRESENT(Backgr_tot) ) THEN
        D%Backgr(0) = Backgr_tot
      END IF
      IF (Nbins .GT. 0) THEN
        IF (PRESENT(Nevents_bin)) THEN
          D%Nevents(1:) = Nevents_bin(:)
        END IF
        IF (PRESENT(Backgr_bin)) THEN
          D%Backgr(1:) = Backgr_bin(:)
        END IF
      END IF
    ELSE
      IF (ALLOCATED(D%Nevents)) DEALLOCATE(D%Nevents)
      IF (ALLOCATED(D%Backgr)) DEALLOCATE(D%Backgr)
      D%Nbins = Nbins
      D%InitSuccess = .False. ! If Nbins is changed, a new efficiency array must be provided
      ALLOCATE(D%Nevents(0:Nbins),D%Backgr(0:Nbins))
      IF ( PRESENT(Nevents_tot) ) THEN
        D%Nevents(0) = Nevents_tot
      ELSE
        D%Nevents(0) = -1
      END IF
      IF ( PRESENT(Backgr_tot) ) THEN
        D%Backgr(0) = Backgr_tot
      ELSE
        D%Backgr(0) = 0
      END IF
      IF (Nbins .GT. 0) THEN
        IF (PRESENT(Nevents_bin)) THEN
          D%Nevents(1:) = Nevents_bin(:)
        ELSE
          D%Nevents(1:) = 0
        END IF
        IF (PRESENT(Backgr_bin)) THEN
          D%Backgr(1:) = Backgr_bin(:)
        ELSE
          D%Backgr(1:) = 0d0
        END IF
      END IF
    END IF
  END IF

  IF ( D%Nbins < 0) THEN
    D%InitSuccess = .False.
    RETURN      
  END IF

  ! Isotope data
  IF (PRESENT(Niso)) THEN
    IF (Niso .EQ. D%Niso) THEN
      IF (PRESENT(Ziso)) THEN
        D%Ziso = Ziso(1:Niso)
        iso_change = .TRUE.
      END IF
      IF (PRESENT(Aiso)) THEN
        D%Aiso = Aiso(1:Niso)
        iso_change = .TRUE.
      END IF
      IF (PRESENT(fiso)) THEN
        D%fiso = fiso(1:Niso)
        iso_change = .TRUE.
      END IF
      IF (iso_change) THEN
        D%Miso = IsotopeMass(D%Ziso,D%Aiso)
      END IF
    ELSE IF (PRESENT(Ziso) .AND. PRESENT(Aiso) .AND. PRESENT(fiso)) THEN
      IF (ALLOCATED(D%Ziso)) DEALLOCATE(D%Ziso)
      IF (ALLOCATED(D%Aiso)) DEALLOCATE(D%Aiso)
      IF (ALLOCATED(D%fiso)) DEALLOCATE(D%fiso)
      IF (ALLOCATED(D%Miso)) DEALLOCATE(D%Miso)
      ALLOCATE(D%Ziso(Niso),D%Aiso(Niso),D%fiso(Niso),D%Miso(Niso))
      D%Niso = Niso
      D%Ziso = Ziso(1:Niso)
      D%Aiso = Aiso(1:Niso)
      D%fiso = fiso(1:Niso)
      D%Miso = IsotopeMass(D%Ziso,D%Aiso)
      D%InitSuccess = .False. ! If Niso is changed, a new efficiency array must be provided
      iso_change = .TRUE.
    END IF
  END IF

  IF (PRESENT(Nelem) .AND. PRESENT(Zelem)) THEN
    ALLOCATE(stoich0(Nelem))
    IF (PRESENT(stoich)) THEN
      stoich0 = stoich
    ELSE
      stoich0 = 1
    END IF
    CALL CompoundIsotopeList(Nelem,Zelem,stoich0,                       &
                             D%Niso,D%Ziso,D%Aiso,D%fiso,D%Miso)
    D%InitSuccess = .False. ! If Niso is changed, a new efficiency array must be provided
    iso_change = .TRUE.
  END IF
  
  IF (.NOT. D%Niso > 0) THEN
    D%InitSuccess = .False.
    RETURN      
  END IF

  ! Exposures
  IF (PRESENT(mass)) THEN
    D%mass     = mass
    D%exposure = D%mass * D%time
  END IF
  IF (PRESENT(time)) THEN
    D%time     = time
    D%exposure = D%mass * D%time
  END IF
  IF (PRESENT(exposure)) THEN
    D%mass     = -1d0
    D%time     = -1d0
    D%exposure = exposure
  END IF

  IF (.NOT. D%exposure > 0d0) THEN
    D%InitSuccess = .False.
    RETURN      
  END IF

  ! Set efficiencies
  ! ...from file (note that right now only one efficiency can be provided for all isotopes)
  IF (PRESENT(eff_file)) THEN
    IF (eff_file .NE. '') THEN
      D%eff_file = eff_file
      CALL LoadEfficiencyFile(eff_file,D%Niso,D%Nbins,D%NE,D%E,D%eff)
      eff_change = .TRUE.
      D%InitSuccess = .TRUE.
    END IF
  ! ...by arguments
  ELSE IF (PRESENT(eff)) THEN
    IF (ALLOCATED(D%eff))  DEALLOCATE(D%eff)
    ALLOCATE(D%eff(D%Niso,NE,0:Nbins))
    IF (PRESENT(Nelem) .AND. PRESENT(Zelem)) THEN
      ind = 1
      DO ind_elem = 1,Nelem
        CALL GetNiso(Zelem(ind_elem),Niso_temp) ! this assigns Niso_temp
        DO ind_iso = 1,Niso_temp
          D%eff(ind,1:NE,0:Nbins) = eff(ind_elem,1:NE,0:Nbins)
          ind = ind + 1
        END DO
      END DO
    ELSE
      D%eff   = eff(1:D%Niso,1:NE,0:Nbins)
    END IF
    eff_change = .TRUE.
    D%InitSuccess = .TRUE.
  ELSE IF (PRESENT(eff_all)) THEN
    IF (ALLOCATED(D%eff))  DEALLOCATE(D%eff)
    ALLOCATE(D%eff(D%Niso,NE,0:Nbins))
    DO ind = 1,D%Niso
      D%eff(ind,1:NE,0:Nbins) = eff_all(1:NE,0:Nbins)
    END DO
    eff_change = .TRUE.
    D%InitSuccess = .TRUE.
  END IF

  ! Save efficiency file name
  IF (PRESENT(eff_filename)) D%eff_file = eff_filename

  IF (.NOT. D%InitSuccess) THEN
    RETURN
  END IF

  ! Include sub-intervals?
  IF (PRESENT(intervals) .AND. D%Nbins .GT. 0) THEN
    IF (intervals .NEQV. D%intervals) eff_change = .TRUE.
    D%intervals = intervals
  END IF
  
  ! Apply threshold cut.
  ! We move all E < Emin tabulation points to Emin.
  IF (PRESENT(Emin)) THEN
    ! First reset to original tabulation
    D%E = MAX(D%E_cache,Emin)
    E_change = .TRUE.
  END IF
  
  ! Calculate weighted form factors (SI)
  IF (ALLOCATED(D%Wsi)) DEALLOCATE(D%Wsi)
  ALLOCATE(D%Wsi(-1:1,D%NE,D%Niso))
  DO Kiso = 1,D%Niso
    CALL CalcWSI(D%Ziso(Kiso),D%Aiso(Kiso),D%NE,                   &
                 EToQ(D%E,D%Miso(Kiso)),D%Wsi(:,:,Kiso))
  END DO

  ! Calculate weighted form factors (SD)
  IF (ALLOCATED(D%Wsd)) DEALLOCATE(D%Wsd)
  ALLOCATE(D%Wsd(-1:1,D%NE,D%Niso))
  DO Kiso = 1,D%Niso
    CALL CalcWSD(D%Ziso(Kiso),D%Aiso(Kiso),D%NE,                   &
                 EToQ(D%E,D%Miso(Kiso)),D%Wsd(:,:,Kiso))
  END DO
  
  ! Resize halo velocity arrays if necessary
  IF (iso_change .OR. E_change) THEN
    IF (ALLOCATED(D%vmin)) DEALLOCATE(D%vmin)
    ALLOCATE(D%vmin(D%NE,D%Niso))
    IF (ALLOCATED(D%eta))  DEALLOCATE(D%eta)
    ALLOCATE(D%eta(D%NE,D%Niso))
  END IF
  
  ! Number of intervals/bins to do calculations for.
  ! Used for array sizing below.
  IF (D%intervals) THEN
    Neff = D%Nbins
  ELSE
    Neff = 0
  END IF
  
  ! Resize dRdEiso if necessary
  IF (iso_change .OR. E_change) THEN
    IF (ALLOCATED(D%dRdEiso)) DEALLOCATE(D%dRdEiso)
    ALLOCATE(D%dRdEiso(D%NE,D%Niso))
  END IF

  ! Resize rate arrays if necessary
  IF (E_change .OR. eff_change) THEN
    IF (ALLOCATED(D%R)) DEALLOCATE(D%R)
    ALLOCATE(D%R(0:Neff))
  END IF
  
  ! Resize event arrays if necessary
  IF (eff_change) THEN
    IF (ALLOCATED(D%MuSignal)) DEALLOCATE(D%MuSignal)
    ALLOCATE(D%MuSignal(0:Neff))
  END IF
  
  ! Set all calculable quantities to zero
  IF (iso_change .OR. E_change .OR. eff_change) THEN
    D%vmin        = 0d0
    D%eta         = 0d0
    D%dRdEiso     = 0d0
    D%R           = 0d0
    D%MuSignal    = 0d0
  END IF
  
END SUBROUTINE
  
END MODULE
